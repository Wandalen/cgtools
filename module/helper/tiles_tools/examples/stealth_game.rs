#![allow(dead_code)]
#![allow(clippy::needless_return)]
#![allow(clippy::implicit_return)]
#![allow(clippy::uninlined_format_args)]
#![allow(clippy::items_after_statements)]
#![allow(clippy::unnecessary_cast)]
#![allow(clippy::doc_markdown)]
#![allow(clippy::cast_sign_loss)]
#![allow(clippy::explicit_iter_loop)]
#![allow(clippy::format_in_format_args)]
#![allow(clippy::cast_precision_loss)]
#![allow(clippy::wildcard_imports)]
#![allow(clippy::too_many_lines)]
#![allow(clippy::std_instead_of_core)]
#![allow(clippy::similar_names)]
#![allow(clippy::duplicated_attributes)]
#![allow(clippy::cast_possible_truncation)]
#![allow(clippy::trivially_copy_pass_by_ref)]
#![allow(clippy::missing_inline_in_public_items)]
#![allow(clippy::useless_vec)]
#![allow(clippy::unnested_or_patterns)]
#![allow(clippy::else_if_without_else)]
#![allow(clippy::unreadable_literal)]
#![allow(clippy::redundant_else)]
#![allow(clippy::map_unwrap_or)]
#![allow(clippy::collapsible_else_if)]
#![allow(clippy::clone_on_copy)]
#![allow(clippy::struct_field_names)]
//! Stealth Game example demonstrating field-of-view mechanics.
//!
//! This example showcases a stealth-based game using the tiles_tools
//! field-of-view system. Features include:
//!
//! - Guard patrol with line-of-sight detection
//! - Player stealth mechanics and hiding spots
//! - Dynamic lighting from torches and lamps
//! - Shadow-based visibility calculations
//! - Multi-layered security with overlapping vision cones
//! - Noise propagation and detection systems
//!
//! Run with: `cargo run --example stealth_game --features enabled`

#![allow(dead_code)]

use tiles_tools::{
  ecs::{World, Position, Health, Stats, Team, AI, Movable},
  coordinates::{
    Distance,
    square::{Coordinate as SquareCoord, EightConnected},
  },
  field_of_view::{FieldOfView, FOVAlgorithm, LightSource, LightingCalculator},
  pathfind::astar,
};

// =============================================================================
// Game-Specific Components
// =============================================================================

/// Stealth component for sneaking and detection.
#[derive(Debug, Clone, Copy)]
struct Stealth {
  /// Stealth skill level (higher = harder to detect)
  stealth_level: u32,
  /// Current stealth state (hiding, moving, etc.)
  state: StealthState,
  /// Noise level generated by current activity
  noise_level: u32,
  /// Whether currently hidden behind cover
  in_cover: bool,
}

impl Stealth {
  pub fn new(level: u32) -> Self {
    Self {
      stealth_level: level,
      state: StealthState::Hidden,
      noise_level: 1,
      in_cover: false,
    }
  }
  
  pub fn start_moving(&mut self) {
    self.state = StealthState::Moving;
    self.noise_level = if self.in_cover { 2 } else { 4 };
  }
  
  pub fn hide(&mut self) {
    self.state = StealthState::Hidden;
    self.noise_level = 0;
  }
  
  pub fn set_cover(&mut self, in_cover: bool) {
    self.in_cover = in_cover;
    if in_cover {
      self.noise_level = self.noise_level.saturating_sub(2);
    }
  }
}

#[derive(Debug, Clone, Copy, PartialEq)]
enum StealthState {
  Hidden,      // Stationary and trying to avoid detection
  Moving,      // Moving but trying to be stealthy
  Exposed,     // Detected or making noise
  Distracted,  // Investigating something
}

/// Vision component for guards and NPCs.
#[derive(Debug, Clone)]
struct Vision {
  /// Base vision range in normal lighting
  base_range: u32,
  /// Field of view angle in degrees (360 = all directions)
  fov_angle: u32,
  /// Direction the entity is currently facing (0-360 degrees)
  facing_direction: u32,
  /// Detection threshold (lower = more sensitive)
  detection_threshold: u32,
  /// Alert level (0 = unaware, 10 = fully alert)
  alert_level: u32,
}

impl Vision {
  pub fn new(range: u32, angle: u32) -> Self {
    Self {
      base_range: range,
      fov_angle: angle,
      facing_direction: 0,
      detection_threshold: 5,
      alert_level: 0,
    }
  }
  
  pub fn face_direction(&mut self, direction: u32) {
    self.facing_direction = direction % 360;
  }
  
  pub fn increase_alert(&mut self, amount: u32) {
    self.alert_level = (self.alert_level + amount).min(10);
  }
  
  pub fn get_effective_range(&self) -> u32 {
    // Alert guards see farther
    self.base_range + (self.alert_level / 2)
  }
}

/// Patrol route component for guard movement.
#[derive(Debug, Clone)]
struct PatrolRoute {
  /// Waypoints in the patrol route
  waypoints: Vec<SquareCoord<EightConnected>>,
  /// Current waypoint index
  current_waypoint: usize,
  /// Time to wait at each waypoint
  wait_time: u32,
  /// Current wait timer
  current_wait: u32,
  /// Whether to reverse route when reaching end
  reverse_route: bool,
  /// Direction of travel (forward/backward)
  going_forward: bool,
}

impl PatrolRoute {
  pub fn new(waypoints: Vec<SquareCoord<EightConnected>>, wait_time: u32) -> Self {
    Self {
      waypoints,
      current_waypoint: 0,
      wait_time,
      current_wait: 0,
      reverse_route: true,
      going_forward: true,
    }
  }
  
  pub fn get_current_target(&self) -> Option<SquareCoord<EightConnected>> {
    self.waypoints.get(self.current_waypoint).copied()
  }
  
  pub fn advance_waypoint(&mut self) {
    if self.current_wait > 0 {
      self.current_wait = self.current_wait.saturating_sub(1);
      return;
    }
    
    if self.reverse_route {
      if self.going_forward {
        if self.current_waypoint + 1 >= self.waypoints.len() {
          self.going_forward = false;
          if self.current_waypoint > 0 {
            self.current_waypoint -= 1;
          }
        } else {
          self.current_waypoint += 1;
        }
      } else {
        if self.current_waypoint == 0 {
          self.going_forward = true;
          self.current_waypoint = 1;
        } else {
          self.current_waypoint -= 1;
        }
      }
    } else {
      self.current_waypoint = (self.current_waypoint + 1) % self.waypoints.len();
    }
    
    self.current_wait = self.wait_time;
  }
}

// =============================================================================
// Game State Management
// =============================================================================

/// Main stealth game state.
struct StealthGame {
  world: World,
  player_entity: hecs::Entity,
  guard_entities: Vec<hecs::Entity>,
  fov_calculator: FieldOfView,
  lighting_calculator: LightingCalculator<SquareCoord<EightConnected>>,
  level_map: LevelMap,
  turn_counter: u32,
  game_state: GameState,
}

#[derive(Debug, Clone, Copy, PartialEq)]
enum GameState {
  Stealth,        // Player is undetected
  Alert,          // Guards are searching
  Detected,       // Player has been spotted
  Victory,        // Player reached objective
  GameOver,       // Player was caught
}

/// Simple level map for obstacle and cover detection.
struct LevelMap {
  width: i32,
  height: i32,
  walls: std::collections::HashSet<SquareCoord<EightConnected>>,
  cover_spots: std::collections::HashSet<SquareCoord<EightConnected>>,
  light_sources: Vec<SquareCoord<EightConnected>>,
  objective: SquareCoord<EightConnected>,
}

impl LevelMap {
  pub fn new(width: i32, height: i32) -> Self {
    let mut map = Self {
      width,
      height,
      walls: std::collections::HashSet::new(),
      cover_spots: std::collections::HashSet::new(),
      light_sources: Vec::new(),
      objective: SquareCoord::<EightConnected>::new(width - 2, height - 2),
    };
    
    // Create a simple level layout
    map.generate_level_layout();
    map
  }
  
  fn generate_level_layout(&mut self) {
    // Create perimeter walls
    for x in 0..self.width {
      self.walls.insert(SquareCoord::<EightConnected>::new(x, 0));
      self.walls.insert(SquareCoord::<EightConnected>::new(x, self.height - 1));
    }
    for y in 0..self.height {
      self.walls.insert(SquareCoord::<EightConnected>::new(0, y));
      self.walls.insert(SquareCoord::<EightConnected>::new(self.width - 1, y));
    }
    
    // Add some interior obstacles
    let obstacles = [
      (5, 3), (5, 4), (5, 5),   // Wall section
      (8, 7), (9, 7), (10, 7),  // Another wall
      (12, 4), (13, 4),         // Small wall
    ];
    
    for &(x, y) in &obstacles {
      if x < self.width && y < self.height {
        self.walls.insert(SquareCoord::<EightConnected>::new(x, y));
      }
    }
    
    // Add cover spots (bushes, crates, etc.)
    let cover_locations = [
      (3, 6), (7, 2), (11, 8), (6, 9), (14, 5)
    ];
    
    for &(x, y) in &cover_locations {
      if x < self.width && y < self.height && !self.walls.contains(&SquareCoord::new(x, y)) {
        self.cover_spots.insert(SquareCoord::<EightConnected>::new(x, y));
      }
    }
    
    // Add light sources (torches)
    self.light_sources = vec![
      SquareCoord::<EightConnected>::new(4, 4),
      SquareCoord::<EightConnected>::new(10, 6),
      SquareCoord::<EightConnected>::new(7, 9),
    ];
  }
  
  pub fn is_wall(&self, coord: &SquareCoord<EightConnected>) -> bool {
    self.walls.contains(coord)
  }
  
  pub fn has_cover(&self, coord: &SquareCoord<EightConnected>) -> bool {
    self.cover_spots.contains(coord)
  }
  
  pub fn blocks_sight(&self, coord: &SquareCoord<EightConnected>) -> bool {
    self.is_wall(coord)
  }
  
  pub fn is_passable(&self, coord: &SquareCoord<EightConnected>) -> bool {
    !self.is_wall(coord) &&
    coord.x >= 0 && coord.x < self.width &&
    coord.y >= 0 && coord.y < self.height
  }
}

impl StealthGame {
  /// Creates a new stealth game.
  pub fn new() -> Self {
    let mut world = World::new();
    let level_map = LevelMap::new(20, 15);
    
    // Create player
    let player_team = Team::new(0);
    let player_entity = world.spawn((
      Position::new(SquareCoord::<EightConnected>::new(2, 2)),
      Health::new(100),
      Stats::new(10, 8, 15, 1), // High speed for stealth
      player_team,
      Movable::new(3),
      Stealth::new(7), // High stealth skill
    ));
    
    // Create guards
    let guard_team = Team::hostile(1);
    let mut guard_entities = Vec::new();
    
    // Guard 1: Patrolling the upper area
    let guard1 = world.spawn((
      Position::new(SquareCoord::<EightConnected>::new(8, 3)),
      Health::new(80),
      Stats::new(12, 10, 8, 1),
      guard_team,
      Movable::new(2),
      AI::new(1.0),
      Vision::new(6, 120), // 120-degree vision cone
      PatrolRoute::new(vec![
        SquareCoord::<EightConnected>::new(8, 3),
        SquareCoord::<EightConnected>::new(12, 3),
        SquareCoord::<EightConnected>::new(12, 6),
        SquareCoord::<EightConnected>::new(8, 6),
      ], 2),
    ));
    guard_entities.push(guard1);
    
    // Guard 2: Stationary guard watching the objective
    let guard2 = world.spawn((
      Position::new(SquareCoord::<EightConnected>::new(16, 11)),
      Health::new(90),
      Stats::new(14, 12, 6, 1),
      guard_team,
      AI::new(1.5),
      Vision::new(8, 180), // Wide field of view
      PatrolRoute::new(vec![
        SquareCoord::<EightConnected>::new(16, 11),
        SquareCoord::<EightConnected>::new(15, 13),
      ], 3),
    ));
    guard_entities.push(guard2);
    
    // Create lighting system
    let mut lighting_calculator = LightingCalculator::new();
    
    // Add torches
    for torch_pos in &level_map.light_sources {
      let torch_light = LightSource::new(torch_pos.clone(), 4, 0.7)
        .with_color(1.0, 0.8, 0.3); // Warm torch light
      lighting_calculator.add_light_source(torch_light);
    }
    
    Self {
      world,
      player_entity,
      guard_entities,
      fov_calculator: FieldOfView::with_algorithm(FOVAlgorithm::Shadowcasting),
      lighting_calculator,
      level_map,
      turn_counter: 0,
      game_state: GameState::Stealth,
    }
  }
  
  /// Processes one turn of the game.
  pub fn process_turn(&mut self) {
    self.turn_counter += 1;
    
    match self.game_state {
      GameState::Stealth => {
        self.process_stealth_turn();
      }
      GameState::Alert => {
        self.process_alert_turn();
      }
      GameState::Detected => {
        self.process_detected_turn();
      }
      _ => {
        // Game over states
        return;
      }
    }
    
    // Check victory condition
    if let Ok(player_pos) = self.world.get::<Position<SquareCoord<EightConnected>>>(self.player_entity) {
      if player_pos.coord.distance(&self.level_map.objective) <= 1 {
        self.game_state = GameState::Victory;
      }
    }
  }
  
  /// Processes a turn in stealth mode.
  fn process_stealth_turn(&mut self) {
    // Update guard patrols
    let guard_entities = self.guard_entities.clone();
    for guard in guard_entities {
      self.update_guard_patrol(guard);
    }
    
    // Check for player detection
    if self.check_player_detection() {
      self.game_state = GameState::Alert;
      println!("üö® Alert! Guards are searching...");
    }
    
    // Simulate player movement (in a real game, this would be input-driven)
    self.simulate_player_movement();
  }
  
  /// Processes a turn in alert mode.
  fn process_alert_turn(&mut self) {
    // Guards move toward last known player position
    if self.check_player_detection() {
      self.game_state = GameState::Detected;
      println!("üéØ Player detected! Game over!");
    }
    
    // Gradually reduce alert level
    if self.turn_counter % 5 == 0 {
      let mut alert_decreased = true;
      for &guard in &self.guard_entities {
        if let Ok(mut vision) = self.world.get_mut::<Vision>(guard) {
          if vision.alert_level > 0 {
            vision.alert_level -= 1;
            alert_decreased = false;
          }
        }
      }
      
      if alert_decreased {
        self.game_state = GameState::Stealth;
        println!("üòå Guards have stopped searching.");
      }
    }
  }
  
  /// Processes a turn when player is detected.
  fn process_detected_turn(&mut self) {
    // Game over - guards converge on player
    self.game_state = GameState::GameOver;
  }
  
  /// Updates a guard's patrol behavior.
  fn update_guard_patrol(&mut self, guard: hecs::Entity) {
    // First get position without any mutable borrows
    let current_pos = {
      if let Ok(pos) = self.world.get::<Position<SquareCoord<EightConnected>>>(guard) {
        pos.coord
      } else {
        return;
      }
    };
    
    // Then get and modify patrol data
    let target_to_move = {
      if let Ok(mut patrol) = self.world.get_mut::<PatrolRoute>(guard) {
        if let Some(target) = patrol.get_current_target() {
          // Check if we've reached the target
          if current_pos.distance(&target) <= 1 {
            patrol.advance_waypoint();
            None
          } else {
            // Need to move toward target
            Some(target)
          }
        } else {
          return;
        }
      } else {
        return;
      }
    };
    
    if let Some(target) = target_to_move {
      self.move_guard_toward(guard, &target);
    }
  }
  
  /// Moves a guard toward a target position.
  fn move_guard_toward(&mut self, guard: hecs::Entity, target: &SquareCoord<EightConnected>) {
    if let Ok(pos) = self.world.get::<Position<SquareCoord<EightConnected>>>(guard) {
      if let Ok(movable) = self.world.get::<Movable>(guard) {
        // Use pathfinding to move toward target
        let path_result = astar(
          &pos.coord,
          target,
          |coord| self.level_map.is_passable(coord),
          |_| 1,
        );
        
        if let Some((path, _cost)) = path_result {
          let move_distance = movable.range.min(path.len() as u32 - 1);
          if move_distance > 0 {
            let new_pos = path[move_distance as usize];
            println!("üö∂ Guard moving from ({}, {}) to ({}, {})", 
                     pos.coord.x, pos.coord.y, new_pos.x, new_pos.y);
          }
        }
      }
    }
  }
  
  /// Checks if any guard can detect the player.
  fn check_player_detection(&mut self) -> bool {
    let (player_coord, player_stealth_state, player_light_level) = {
      if let Ok(player_pos) = self.world.get::<Position<SquareCoord<EightConnected>>>(self.player_entity) {
        if let Ok(player_stealth) = self.world.get::<Stealth>(self.player_entity) {
          
          // Calculate lighting at player position
          let lighting = self.lighting_calculator.calculate_lighting(|coord| {
            self.level_map.blocks_sight(coord)
          });
          
          let player_light_level = lighting.get(&player_pos.coord).unwrap_or(&0.0);
          (player_pos.coord, *player_stealth, *player_light_level)
        } else {
          return false;
        }
      } else {
        return false;
      }
    };
    
    // Check each guard's detection ability
    let guard_entities = self.guard_entities.clone();
    for guard in guard_entities {
      let guard_coord = {
        if let Ok(guard_pos) = self.world.get::<Position<SquareCoord<EightConnected>>>(guard) {
          guard_pos.coord
        } else {
          continue;
        }
      };
      
      if let Ok(mut vision) = self.world.get_mut::<Vision>(guard) {
              
        let distance = guard_coord.distance(&player_coord);
        let effective_range = vision.get_effective_range();
        
        if distance <= effective_range {
          // Check line of sight
          let has_los = self.fov_calculator.line_of_sight(
            &guard_coord,
            &player_coord,
            |coord| self.level_map.blocks_sight(coord)
          );
          
          if has_los {
            // Calculate detection chance
            let base_detection = 10 - player_stealth_state.stealth_level;
            let light_modifier = (player_light_level * 5.0) as u32;
            let distance_modifier = (effective_range - distance) / 2;
            let cover_modifier = if player_stealth_state.in_cover { 0 } else { 3 };
            let noise_modifier = player_stealth_state.noise_level;
            
            let detection_score = base_detection + light_modifier + 
                                distance_modifier + cover_modifier + noise_modifier;
            
            if detection_score >= vision.detection_threshold {
              vision.increase_alert(3);
              if vision.alert_level >= 7 {
                return true; // Player detected!
              }
            }
          }
        }
      }
    }
    false
  }
  
  /// Simulates player movement for demonstration.
  fn simulate_player_movement(&mut self) {
    let (current_pos, objective) = {
      if let Ok(player_pos) = self.world.get::<Position<SquareCoord<EightConnected>>>(self.player_entity) {
        (player_pos.coord, self.level_map.objective)
      } else {
        return;
      }
    };
    
    // Find path to objective
    if let Some((path, _cost)) = astar(
      &current_pos,
      &objective,
      |coord| self.level_map.is_passable(coord),
      |_| 1,
    ) {
      if path.len() > 1 {
        let next_pos = path[1];
        
        // Check if it's safe to move there
        if self.is_position_safe_for_player(&next_pos) {
          println!("üö∂ Player moving from ({}, {}) to ({}, {})",
                   current_pos.x, current_pos.y, next_pos.x, next_pos.y);
          
          // Update stealth state
          if let Ok(mut stealth) = self.world.get_mut::<Stealth>(self.player_entity) {
            stealth.start_moving();
            stealth.set_cover(self.level_map.has_cover(&next_pos));
          }
        } else {
          // Wait and hide
          if let Ok(mut stealth) = self.world.get_mut::<Stealth>(self.player_entity) {
            stealth.hide();
          }
          println!("üïµÔ∏è Player waiting for guards to pass...");
        }
      }
    }
  }
  
  /// Checks if a position is safe for the player to move to.
  fn is_position_safe_for_player(&self, pos: &SquareCoord<EightConnected>) -> bool {
    // Check if any guard can see this position
    for &guard in &self.guard_entities {
      if let Ok(guard_pos) = self.world.get::<Position<SquareCoord<EightConnected>>>(guard) {
        if let Ok(vision) = self.world.get::<Vision>(guard) {
          let distance = guard_pos.coord.distance(pos);
          if distance <= vision.get_effective_range() {
            let has_los = self.fov_calculator.line_of_sight(
              &guard_pos.coord,
              pos,
              |coord| self.level_map.blocks_sight(coord)
            );
            
            if has_los {
              return false; // Position is visible to guard
            }
          }
        }
      }
    }
    true
  }
  
  /// Prints the current game state.
  pub fn print_game_state(&self) {
    println!("\n=== Turn {} ===", self.turn_counter);
    println!("Game State: {:?}", self.game_state);
    
    // Print level with entities
    self.print_level_map();
    
    // Print player status
    if let Ok(player_pos) = self.world.get::<Position<SquareCoord<EightConnected>>>(self.player_entity) {
      if let Ok(stealth) = self.world.get::<Stealth>(self.player_entity) {
        println!("üïµÔ∏è Player at ({}, {}): {:?}, Noise: {}, Cover: {}", 
                 player_pos.coord.x, player_pos.coord.y,
                 stealth.state, stealth.noise_level, stealth.in_cover);
      }
    }
    
    // Print guard status
    for (i, &guard) in self.guard_entities.iter().enumerate() {
      if let Ok(guard_pos) = self.world.get::<Position<SquareCoord<EightConnected>>>(guard) {
        if let Ok(vision) = self.world.get::<Vision>(guard) {
          println!("üëÆ Guard {} at ({}, {}): Alert Level {}/10", 
                   i + 1, guard_pos.coord.x, guard_pos.coord.y, vision.alert_level);
        }
      }
    }
  }
  
  /// Prints the level map with entities and lighting.
  fn print_level_map(&self) {
    let lighting = self.lighting_calculator.calculate_lighting(|coord| {
      self.level_map.blocks_sight(coord)
    });
    
    println!("\nüìç Level Map:");
    println!("üïµÔ∏è = Player, üëÆ = Guard, üèÜ = Objective, ‚¨õ = Wall");
    println!("üåø = Cover, üïØÔ∏è = Torch, ‚ñë = Dark, ‚ñì = Dim, ‚ñÄ = Lit");
    
    for y in 0..self.level_map.height {
      for x in 0..self.level_map.width {
        let coord = SquareCoord::<EightConnected>::new(x, y);
        
        // Check for entities first
        let mut symbol = None;
        
        // Check for player
        if let Ok(player_pos) = self.world.get::<Position<SquareCoord<EightConnected>>>(self.player_entity) {
          if player_pos.coord == coord {
            symbol = Some("üïµÔ∏è");
          }
        }
        
        // Check for guards
        if symbol.is_none() {
          for &guard in &self.guard_entities {
            if let Ok(guard_pos) = self.world.get::<Position<SquareCoord<EightConnected>>>(guard) {
              if guard_pos.coord == coord {
                symbol = Some("üëÆ");
                break;
              }
            }
          }
        }
        
        // Check for objective
        if symbol.is_none() && coord == self.level_map.objective {
          symbol = Some("üèÜ");
        }
        
        // Check for light sources
        if symbol.is_none() && self.level_map.light_sources.contains(&coord) {
          symbol = Some("üïØÔ∏è");
        }
        
        // Check for terrain
        if symbol.is_none() {
          if self.level_map.is_wall(&coord) {
            symbol = Some("‚¨õ");
          } else if self.level_map.has_cover(&coord) {
            symbol = Some("üåø");
          } else {
            // Show lighting level
            let light_level = lighting.get(&coord).unwrap_or(&0.0);
            if *light_level >= 0.7 {
              symbol = Some("‚ñÄ"); // Bright
            } else if *light_level >= 0.3 {
              symbol = Some("‚ñì"); // Dim
            } else {
              symbol = Some("‚ñë"); // Dark
            }
          }
        }
        
        print!("{}", symbol.unwrap_or(" "));
      }
      println!();
    }
  }
  
  /// Runs the complete stealth game simulation.
  pub fn run_simulation(&mut self) {
    println!("üéØ Stealth Game Simulation");
    println!("=========================");
    println!("Objective: Reach the üèÜ without being detected!");
    println!("Use cover (üåø) and darkness to avoid guards (üëÆ)");
    
    self.print_game_state();
    
    // Run game loop
    for turn in 1..=30 {
      self.process_turn();
      self.print_game_state();
      
      match self.game_state {
        GameState::Victory => {
          println!("üèÜ VICTORY! You reached the objective undetected!");
          break;
        }
        GameState::GameOver => {
          println!("üíÄ GAME OVER! You were caught by the guards!");
          break;
        }
        _ => {
          if turn >= 30 {
            println!("‚è∞ Simulation ended - mission continues...");
            break;
          }
        }
      }
      
      std::thread::sleep(std::time::Duration::from_millis(1500));
    }
  }
}

/// Main entry point for the stealth game demo.
fn main() {
  let mut game = StealthGame::new();
  game.run_simulation();
  
  println!("\n‚ú® Stealth Game Demo Complete!");
  println!("This example showcases:");
  println!("‚Ä¢ Field-of-view calculations for line-of-sight");
  println!("‚Ä¢ Multi-source dynamic lighting systems");
  println!("‚Ä¢ Stealth mechanics with detection algorithms");
  println!("‚Ä¢ Guard AI with patrol routes and alertness");
  println!("‚Ä¢ Environmental factors (cover, lighting, noise)");
}