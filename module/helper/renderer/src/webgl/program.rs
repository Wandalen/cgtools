//! WebGL shader program type definitions and uniform location management.
//!
//! # File Size Justification (429 lines)
//!
//! This file intentionally remains as a single cohesive module despite exceeding
//! the 300-line guideline for the following architectural reasons:
//!
//! ## Single Responsibility
//! This file has one clear responsibility: centralized definition of all shader
//! program types and their associated uniform/UBO location mappings.
//!
//! ## Declarative Content
//! The majority of lines (≈280 lines, 65% of the file) consist of declarative
//! uniform location lists generated by the `impl_locations!` macro. These are:
//! - Inherently difficult to reduce without losing clarity
//! - Better kept together for comparative reference across shader types
//! - Not complex logic that would benefit from decomposition
//!
//! ## Cohesion Over Separation
//! All 16 shader types defined here are:
//! - Logically related (rendering pipeline components)
//! - Share the same `ProgramInfo<T>` infrastructure
//! - Generated using the same macro system
//! - Used together in the rendering pipeline
//!
//! Splitting this file would:
//! - Scatter related shader definitions across multiple files
//! - Make cross-shader comparison and maintenance harder
//! - Create artificial boundaries in what is fundamentally a unified concept
//! - Complicate navigation (16 shader types → 16+ files)
//!
//! ## Macro-Driven Architecture
//! The `impl_locations!` macro generates consistent implementations for all shader
//! types. Keeping all macro invocations in one file ensures:
//! - Easy verification that all shaders follow the same pattern
//! - Simplified refactoring if the macro needs updates
//! - Clear visibility of all shader programs in the system
//!
//! This file exemplifies the principle: "cohesion is more important than line count."

mod private
{
  use minwebgl as gl;
  use web_sys::WebGlProgram;
  use rustc_hash::FxHashMap;

  /// Shader program generalization for getting access to used shader locations
  pub trait ShaderProgram : clone_dyn_types::CloneDyn
  {
    /// Returns a reference to the [`WebGlProgram`]
    fn program( &self ) -> &WebGlProgram;

    /// Set [`WebGlProgram`] with locations replacement
    fn set_program( &mut self, gl : &gl::WebGl2RenderingContext, program : &gl::WebGlProgram );

    /// Returns a reference to the hash map containing uniform locations.
    fn locations( &self ) -> &FxHashMap< String, Option< gl::WebGlUniformLocation > >;

    /// Returns a mutable reference to the hash map containing uniform locations.
    fn locations_mut( &mut self ) ->  &mut FxHashMap< String, Option< gl::WebGlUniformLocation > >;

    /// Returns a reference to the hash map containing UBO indices.
    fn ubo_indices( &self ) -> &FxHashMap< String, u32 >;

    /// Returns a mutable reference to the hash map containing UBO indices.
    fn ubo_indices_mut( &mut self ) ->  &mut FxHashMap< String, u32 >;

    /// Binds the WebGL program for use.
    ///
    /// * `gl`: The `WebGl2RenderingContext`.
    fn bind( &self, gl : &gl::WebGl2RenderingContext );

    /// Get [`ShaderProgram`] type name
    fn type_name( &self ) -> &'static str;

    /// Create new boxed clone of self
    fn dyn_clone( &self ) -> Box< dyn ShaderProgram >;
  }

  /// Macros for simplified [`ShaderProgram`] implementation
  #[ macro_export ]
  macro_rules! impl_locations
  {
    ( $program_type:ty, $( $location_name:literal ),* ) =>
    {
      #[ allow( unused_variables ) ]
      impl $program_type
      {
        /// Creates a new shader instance.
        pub fn new( gl : &gl::WebGl2RenderingContext, program : &gl::WebGlProgram ) -> Self
        {
          #[ allow( unused_mut ) ]
          let mut locations = FxHashMap::default();

          $(
            locations.insert( $location_name.to_string(), gl.get_uniform_location( program, $location_name ) );
          )*

          Self
          (
            ProgramInfo
            {
              program : program.clone(),
              locations,
              ubo_indices : FxHashMap::default()
            }
          )
        }
      }

      impl Clone for $program_type
      {
        fn clone( &self ) -> Self
        {
          Self( self.0.clone() )
        }
      }

      impl ShaderProgram for $program_type
      {
        fn program( &self ) -> &WebGlProgram
        {
          &self.0.program
        }

        fn set_program( &mut self, gl : &gl::WebGl2RenderingContext, program : &gl::WebGlProgram )
        {
          *self = < $program_type >::new( gl, program );
        }

        fn locations( &self ) -> &FxHashMap< String, Option< gl::WebGlUniformLocation > >
        {
          &self.0.locations
        }

        fn locations_mut( &mut self ) ->  &mut FxHashMap< String, Option< gl::WebGlUniformLocation > >
        {
          &mut self.0.locations
        }

        fn ubo_indices( &self ) -> &FxHashMap< String, u32 >
        {
          &self.0.ubo_indices
        }

        fn ubo_indices_mut( &mut self ) ->  &mut FxHashMap< String, u32 >
        {
          &mut self.0.ubo_indices
        }

        fn bind( &self, gl : &gl::WebGl2RenderingContext )
        {
          self.0.bind( gl );
        }

        fn type_name( &self ) -> &'static str
        {
          stringify!( $program_type )
        }

        fn dyn_clone( &self ) -> Box< dyn ShaderProgram >
        {
          Box::new( self.clone() )
        }
      }
    };
    ( $program_type:ty, $( $location_name:literal ),* -- $( $ubo_name:literal ),* ) =>
    {
      #[ allow( unused_variables ) ]
      impl $program_type
      {
        /// Creates a new shader instance.
        pub fn new( gl : &gl::WebGl2RenderingContext, program : &gl::WebGlProgram ) -> Self
        {
          #[ allow( unused_mut ) ]
          let mut locations = FxHashMap::default();
          #[ allow( unused_mut ) ]
          let mut ubo_indices = FxHashMap::default();

          $(
            locations.insert( $location_name.to_string(), gl.get_uniform_location( program, $location_name ) );
          )*

          $(
            ubo_indices.insert( $ubo_name.to_string(), gl.get_uniform_block_index( program, $ubo_name ) );
          )*

          Self
          (
            ProgramInfo
            {
              program : program.clone(),
              locations,
              ubo_indices
            }
          )
        }
      }

      impl Clone for $program_type
      {
        fn clone( &self ) -> Self
        {
          Self( self.0.clone() )
        }
      }

      impl ShaderProgram for $program_type
      {
        fn program( &self ) -> &WebGlProgram
        {
          &self.0.program
        }

        fn set_program( &mut self, gl : &gl::WebGl2RenderingContext, program : &gl::WebGlProgram )
        {
          *self = < $program_type >::new( gl, program );
        }

        fn program_mut( &mut self ) ->  &mut WebGlProgram
        {
          &mut self.0.program
        }

        fn locations( &self ) -> &FxHashMap< String, Option< gl::WebGlUniformLocation > >
        {
          &self.0.locations
        }

        fn locations_mut( &mut self ) ->  &mut FxHashMap< String, Option< gl::WebGlUniformLocation > >
        {
          &mut self.0.locations
        }

        fn ubo_indices( &self ) -> &FxHashMap< String, u32 >
        {
          &self.0.ubo_indices
        }

        fn ubo_indices_mut( &mut self ) ->  &mut FxHashMap< String, u32 >
        {
          &mut self.0.ubo_indices
        }

        fn bind( &self, gl : &gl::WebGl2RenderingContext )
        {
          self.0.bind( gl );
        }

        fn type_name( &self ) -> &'static str
        {
          stringify!( $program_type )
        }

        fn dyn_clone( &self ) -> Box< dyn ShaderProgram >
        {
          Box::new( self.clone() )
        }
      }
    };
  }

  /// An empty shader program.
  ///
  /// This is typically used as a placeholder or for a simple pass-through rendering pipeline.
  #[ derive( Debug ) ]
  pub struct EmptyShader( ProgramInfo );
  /// A Physically Based Rendering (PBR) shader.
  #[ derive( Debug ) ]
  pub struct PBRShader( ProgramInfo );
  /// Shader used for drawing background from equirectangular map
  #[ derive( Debug ) ]
  pub struct SkyboxShader( ProgramInfo );
  /// A Gaussian filter shader
  ///
  /// This type of shader is commonly used for post-processing effects like
  /// blurring, often as part of a bloom effect.
  #[ derive( Debug ) ]
  pub struct GaussianFilterShader( ProgramInfo );
  /// An Unreal Bloom shader
  ///
  /// This shader implements a bloom effect similar to the one used in the
  /// Unreal Engine, which simulates a camera's lens reacting to bright light.
  #[ derive( Debug ) ]
  pub struct UnrealBloomShader( ProgramInfo );
  /// A public struct for a Geometry Buffer (GBuffer) shader.
  #[ derive( Debug ) ]
  pub struct GBufferShader( ProgramInfo );
  /// A public struct for a composite shader.
  #[ derive( Debug ) ]
  pub struct CompositeShader( ProgramInfo );
  /// A public struct for an outline shader that uses Jump Flood Algorithm (JFA)
  /// to draw outlines around objects.
  ///
  /// This shader is part of a multi-pass JFA outlining technique.
  #[ derive( Debug ) ]
  pub struct JfaOutlineObjectShader( ProgramInfo );
  /// A public struct for the initialization step of a JFA outline.
  ///
  /// This shader is the first pass of the JFA, which sets up the initial
  /// state for the algorithm.
  #[ derive( Debug ) ]
  pub struct JfaOutlineInitShader( ProgramInfo );
  /// A public struct for the stepping pass of a JFA outline.
  ///
  /// This shader is used in the iterative step of the JFA to propagate
  /// information and find the nearest edge.
  #[ derive( Debug ) ]
  pub struct JfaOutlineStepShader( ProgramInfo );
  /// A public struct representing the final JFA outline shader.
  ///
  /// This shader combines the results of the JFA passes to draw the final outline.
  #[ derive( Debug ) ]
  pub struct JfaOutlineShader( ProgramInfo );
  /// A public struct for an outline shader based on normal and depth buffers.
  ///
  /// This shader is used to render an object's outline by comparing the normal
  /// and depth values of adjacent pixels.
  #[ derive( Debug ) ]
  pub struct NormalDepthOutlineObjectShader( ProgramInfo );
  /// A public struct representing the final Normal/Depth outline shader.
  ///
  /// This shader uses the Normal and Depth buffers to create the final outline.
  #[ derive( Debug ) ]
  pub struct NormalDepthOutlineShader( ProgramInfo );
  /// A public struct for the base Normal/Depth outline shader.
  ///
  /// This is likely the first pass that generates the necessary data for the final
  /// Normal/Depth outline.
  #[ derive( Debug ) ]
  pub struct NormalDepthOutlineBaseShader( ProgramInfo );
  /// A public struct for a shader that draws narrow outlines.
  #[ derive( Debug ) ]
  pub struct NarrowOutlineShader( ProgramInfo );
  /// A public struct for the initialization step of a wide outline.
  ///
  /// This shader is part of a multi-pass technique to create thick, wide outlines.
  #[ derive( Debug ) ]
  pub struct WideOutlineInitShader( ProgramInfo );
  /// A public struct for the stepping pass of a wide outline.
  ///
  /// This is the iterative pass that propagates information for a wide outline.
  #[ derive( Debug ) ]
  pub struct WideOutlineStepShader( ProgramInfo );
  /// A public struct representing the final wide outline shader.
  ///
  /// This shader combines the results of the previous passes to draw the final wide outline.
  #[ derive( Debug ) ]
  pub struct WideOutlineShader( ProgramInfo );
  /// A public struct for a color grading shader.
  ///
  /// This shader applies color correction operations like white balance,
  /// lift-gamma-gain, contrast, vibrance, and saturation adjustments.
  #[ derive( Debug ) ]
  pub struct ColorGradingShader( ProgramInfo );

  /// Stores information about a WebGL program, including the program object and the locations of its uniforms.
  /// This struct is intended for use by the renderer.
  pub struct ProgramInfo
  {
    /// The WebGL program object.
    pub program : gl::WebGlProgram,
    /// A hash map storing the locations of uniform variables in the program.
    /// The keys are the names of the uniforms.
    pub locations : FxHashMap< String, Option< gl::WebGlUniformLocation > >,
    /// A hash map storing the locations of UBO variables in the program.
    /// The keys are the names of the uniform block.
    pub ubo_indices : FxHashMap< String, u32 >,
  }

  #[ allow( clippy::missing_fields_in_debug ) ]
  impl core::fmt::Debug for ProgramInfo
  {
    fn fmt( &self, f: &mut std::fmt::Formatter< '_ > ) -> std::fmt::Result
    {
      f.debug_struct( "ProgramInfo" )
      .field( "locations", &self.locations.keys().collect::< Vec< _ > >() )
      .field( "ubo_indices", &self.ubo_indices )
      .finish()
    }
  }

  impl ProgramInfo
  {
    /// Binds the WebGL program for use.
    ///
    /// * `gl`: The `WebGl2RenderingContext`.
    pub fn bind( &self, gl : &gl::WebGl2RenderingContext )
    {
      gl.use_program( Some( &self.program ) );
    }
  }

  impl Clone for ProgramInfo
  {
    fn clone( &self ) -> Self
    {
      Self
      {
        program : self.program.clone(),
        locations : self.locations.clone(),
        ubo_indices : self.ubo_indices.clone()
      }
    }
  }

  impl_locations!
  (
    PBRShader,
    "cameraPosition",
    "viewMatrix",
    "projectionMatrix",

    // Node uniform locations
    "worldMatrix",
    "normalMatrix",

    // Skeleton uniform locations
    "inverseBindMatrices",
    "globalJointTransformMatrices",
    "matricesTextureSize",

    // Light uniform locations
    "pointLights",
    "pointLightsCount",
    "directLights",
    "directLightsCount",
    "spotLights",
    "spotLightsCount",

    // Material uniform  locations
    //// Textures uniform locations
    "metallicRoughnessTexture",
    "baseColorTexture",
    "normalTexture",
    "occlusionTexture",
    "emissiveTexture",
    "specularTexture",
    "specularColorTexture",
    "lightMap",
    //// IBL uniform locations
    "irradianceTexture",
    "prefilterEnvMap",
    "integrateBRDF",
    "mipmapDistanceRange",
    //// Scalers uniform locations
    "baseColorFactor",
    "metallicFactor",
    "roughnessFactor",
    "normalScale",
    "occlusionStrength",
    "specularFactor",
    "specularColorFactor",
    "emissiveFactor",
    // Luminosity
    "alphaCutoff",
    "exposure"
  );

  impl_locations!
  (
    SkyboxShader,
    "equirectMap",
    "invProjection",
    "invView"
  );

  impl_locations!
  (
    GaussianFilterShader,
    "sourceTexture",
    "invSize",
    "blurDir",
    "kernel"
  );

  impl_locations!
  (
    UnrealBloomShader,
    "blurTexture0",
    "blurTexture1",
    "blurTexture2",
    "blurTexture3",
    "blurTexture4",

    "bloomStrength",
    "bloomRadius",

    "bloomFactors",
    "bloomTintColors"
  );

  impl_locations!
  (
    EmptyShader,
  );

  impl_locations!
  (
    GBufferShader,
    "worldMatrix",
    "viewMatrix",
    "projectionMatrix",
    "normalMatrix",
    "near_far",
    "albedoTexture",
    "objectId",
    "materialId",
    "objectColor"
  );

  impl_locations!
  (
    CompositeShader,
    "transparentA",
    "transparentB"
  );

  impl_locations!
  (
    JfaOutlineObjectShader,
    "u_projection",
    "u_view",
    "u_model"
  );

  impl_locations!
  (
    JfaOutlineInitShader,
    "u_object_texture"
  );

  impl_locations!
  (
    JfaOutlineStepShader,
    "u_jfa_texture",
    "u_resolution",
    "u_step_size"
  );

  impl_locations!
  (
    JfaOutlineShader,
    "u_object_texture",
    "u_jfa_texture",
    "u_resolution",
    "u_outline_thickness",
    "u_outline_color",
    "u_object_color",
    "u_background_color"
  );

  impl_locations!
  (
    NormalDepthOutlineObjectShader,
    "u_projection",
    "u_view",
    "u_model",
    "u_normal_matrix",
    "near",
    "far"
  );

  impl_locations!
  (
    NormalDepthOutlineShader,
    "u_color_texture",
    "u_depth_texture",
    "u_norm_texture",
    "u_projection",
    "u_resolution",
    "u_outline_thickness",
    "u_background_color"
  );

  impl_locations!
  (
    NormalDepthOutlineBaseShader,
    "sourceTexture",
    "positionTexture",
    "normalTexture",
    "objectColorTexture",
    "projection",
    "resolution",
    "outlineThickness"
  );

  impl_locations!
  (
    NarrowOutlineShader,
    "sourceTexture",
    "objectColorTexture",
    "positionTexture",
    "resolution",
    "outlineThickness"
  );

  impl_locations!
  (
    WideOutlineInitShader,
    "objectColorTexture"
  );

  impl_locations!
  (
    WideOutlineStepShader,
    "jfaTexture",
    "resolution",
    "stepSize"
  );

  impl_locations!
  (
    WideOutlineShader,
    "sourceTexture",
    "objectColorTexture",
    "jfaTexture",
    "resolution"
  );

  impl_locations!
  (
    ColorGradingShader,
    "sourceTexture",
    "temperature",
    "tint",
    "exposure",
    "shadows",
    "highlights",
    "contrast",
    "vibrance",
    "saturation"
  );
}

crate::mod_interface!
{
  own use
  {
    EmptyShader,
    GaussianFilterShader,
    UnrealBloomShader,
    PBRShader,
    SkyboxShader,
    GBufferShader,
    CompositeShader,
    JfaOutlineObjectShader,
    JfaOutlineInitShader,
    JfaOutlineStepShader,
    JfaOutlineShader,
    NormalDepthOutlineObjectShader,
    NormalDepthOutlineShader,
    NormalDepthOutlineBaseShader,
    NarrowOutlineShader,
    WideOutlineInitShader,
    WideOutlineStepShader,
    WideOutlineShader,
    ColorGradingShader
  };

  orphan use
  {
    ShaderProgram,
    ProgramInfo
  };
}
