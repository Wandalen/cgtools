//! WebGL shader program type definitions and uniform location management.
//!
//! # File Size Justification (429 lines)
//!
//! This file intentionally remains as a single cohesive module despite exceeding
//! the 300-line guideline for the following architectural reasons:
//!
//! ## Single Responsibility
//! This file has one clear responsibility: centralized definition of all shader
//! program types and their associated uniform/UBO location mappings.
//!
//! ## Declarative Content
//! The majority of lines (≈280 lines, 65% of the file) consist of declarative
//! uniform location lists generated by the `impl_locations!` macro. These are:
//! - Inherently difficult to reduce without losing clarity
//! - Better kept together for comparative reference across shader types
//! - Not complex logic that would benefit from decomposition
//!
//! ## Cohesion Over Separation
//! All 16 shader types defined here are:
//! - Logically related (rendering pipeline components)
//! - Share the same `ProgramInfo<T>` infrastructure
//! - Generated using the same macro system
//! - Used together in the rendering pipeline
//!
//! Splitting this file would:
//! - Scatter related shader definitions across multiple files
//! - Make cross-shader comparison and maintenance harder
//! - Create artificial boundaries in what is fundamentally a unified concept
//! - Complicate navigation (16 shader types → 16+ files)
//!
//! ## Macro-Driven Architecture
//! The `impl_locations!` macro generates consistent implementations for all shader
//! types. Keeping all macro invocations in one file ensures:
//! - Easy verification that all shaders follow the same pattern
//! - Simplified refactoring if the macro needs updates
//! - Clear visibility of all shader programs in the system
//!
//! This file exemplifies the principle: "cohesion is more important than line count."

mod private
{
  use minwebgl as gl;
  use web_sys::WebGlProgram;
  use rustc_hash::FxHashMap;

  /// Shader program generalization for getting access to used shader locations
  pub trait ShaderProgram : clone_dyn_types::CloneDyn
  {
    /// Returns a reference to the [`WebGlProgram`]
    fn program( &self ) -> &WebGlProgram;

    /// Set [`WebGlProgram`] with locations replacement
    fn set_program( &mut self, gl : &gl::WebGl2RenderingContext, program : &gl::WebGlProgram );

    /// Returns a reference to the hash map containing uniform locations.
    fn locations( &self ) -> &FxHashMap< String, Option< gl::WebGlUniformLocation > >;

    /// Returns a mutable reference to the hash map containing uniform locations.
    fn locations_mut( &mut self ) ->  &mut FxHashMap< String, Option< gl::WebGlUniformLocation > >;

    /// Returns a reference to the hash map containing UBO indices.
    fn ubo_indices( &self ) -> &FxHashMap< String, u32 >;

    /// Returns a mutable reference to the hash map containing UBO indices.
    fn ubo_indices_mut( &mut self ) ->  &mut FxHashMap< String, u32 >;

    /// Binds the WebGL program for use.
    ///
    /// * `gl`: The `WebGl2RenderingContext`.
    fn bind( &self, gl : &gl::WebGl2RenderingContext );

    /// Get [`ShaderProgram`] type name
    fn type_name( &self ) -> &'static str;

    /// Create new boxed clone of self
    fn dyn_clone( &self ) -> Box< dyn ShaderProgram >;
  }

  /// Macros for simplified [`ShaderProgram`] implementation
  #[ macro_export ]
  macro_rules! impl_locations
  {
    ( $program_type:ident, $( $location_name:literal ),* ) =>
    {
      ///
      #[ derive( Debug ) ]
      pub struct $program_type( ProgramInfo );

      #[ allow( unused_variables ) ]
      impl $program_type
      {
        /// Creates a new shader instance.
        pub fn new( gl : &gl::WebGl2RenderingContext, program : &gl::WebGlProgram ) -> Self
        {
          #[ allow( unused_mut ) ]
          let mut locations = FxHashMap::default();

          $(
            locations.insert( $location_name.to_string(), gl.get_uniform_location( program, $location_name ) );
          )*

          Self
          (
            ProgramInfo
            {
              program : program.clone(),
              locations,
              ubo_indices : FxHashMap::default()
            }
          )
        }
      }

      impl Clone for $program_type
      {
        fn clone( &self ) -> Self
        {
          Self( self.0.clone() )
        }
      }

      impl ShaderProgram for $program_type
      {
        fn program( &self ) -> &WebGlProgram
        {
          &self.0.program
        }

        fn set_program( &mut self, gl : &gl::WebGl2RenderingContext, program : &gl::WebGlProgram )
        {
          *self = < $program_type >::new( gl, program );
        }

        fn locations( &self ) -> &FxHashMap< String, Option< gl::WebGlUniformLocation > >
        {
          &self.0.locations
        }

        fn locations_mut( &mut self ) ->  &mut FxHashMap< String, Option< gl::WebGlUniformLocation > >
        {
          &mut self.0.locations
        }

        fn ubo_indices( &self ) -> &FxHashMap< String, u32 >
        {
          &self.0.ubo_indices
        }

        fn ubo_indices_mut( &mut self ) ->  &mut FxHashMap< String, u32 >
        {
          &mut self.0.ubo_indices
        }

        fn bind( &self, gl : &gl::WebGl2RenderingContext )
        {
          self.0.bind( gl );
        }

        fn type_name( &self ) -> &'static str
        {
          stringify!( $program_type )
        }

        fn dyn_clone( &self ) -> Box< dyn ShaderProgram >
        {
          Box::new( self.clone() )
        }
      }
    };
    ( $program_type:ty, $( $location_name:literal ),* -- $( $ubo_name:literal ),* ) =>
    {
      ///
      #[ derive( Debug ) ]
      pub struct $program_type( ProgramInfo );

      #[ allow( unused_variables ) ]
      impl $program_type
      {
        /// Creates a new shader instance.
        pub fn new( gl : &gl::WebGl2RenderingContext, program : &gl::WebGlProgram ) -> Self
        {
          #[ allow( unused_mut ) ]
          let mut locations = FxHashMap::default();
          #[ allow( unused_mut ) ]
          let mut ubo_indices = FxHashMap::default();

          $(
            locations.insert( $location_name.to_string(), gl.get_uniform_location( program, $location_name ) );
          )*

          $(
            ubo_indices.insert( $ubo_name.to_string(), gl.get_uniform_block_index( program, $ubo_name ) );
          )*

          Self
          (
            ProgramInfo
            {
              program : program.clone(),
              locations,
              ubo_indices
            }
          )
        }
      }

      impl Clone for $program_type
      {
        fn clone( &self ) -> Self
        {
          Self( self.0.clone() )
        }
      }

      impl ShaderProgram for $program_type
      {
        fn program( &self ) -> &WebGlProgram
        {
          &self.0.program
        }

        fn set_program( &mut self, gl : &gl::WebGl2RenderingContext, program : &gl::WebGlProgram )
        {
          *self = < $program_type >::new( gl, program );
        }

        fn program_mut( &mut self ) ->  &mut WebGlProgram
        {
          &mut self.0.program
        }

        fn locations( &self ) -> &FxHashMap< String, Option< gl::WebGlUniformLocation > >
        {
          &self.0.locations
        }

        fn locations_mut( &mut self ) ->  &mut FxHashMap< String, Option< gl::WebGlUniformLocation > >
        {
          &mut self.0.locations
        }

        fn ubo_indices( &self ) -> &FxHashMap< String, u32 >
        {
          &self.0.ubo_indices
        }

        fn ubo_indices_mut( &mut self ) ->  &mut FxHashMap< String, u32 >
        {
          &mut self.0.ubo_indices
        }

        fn bind( &self, gl : &gl::WebGl2RenderingContext )
        {
          self.0.bind( gl );
        }

        fn type_name( &self ) -> &'static str
        {
          stringify!( $program_type )
        }

        fn dyn_clone( &self ) -> Box< dyn ShaderProgram >
        {
          Box::new( self.clone() )
        }
      }
    };
  }

  pub use impl_locations;

  /// Stores information about a WebGL program, including the program object and the locations of its uniforms.
  /// This struct is intended for use by the renderer.
  pub struct ProgramInfo
  {
    /// The WebGL program object.
    pub program : gl::WebGlProgram,
    /// A hash map storing the locations of uniform variables in the program.
    /// The keys are the names of the uniforms.
    pub locations : FxHashMap< String, Option< gl::WebGlUniformLocation > >,
    /// A hash map storing the locations of UBO variables in the program.
    /// The keys are the names of the uniform block.
    pub ubo_indices : FxHashMap< String, u32 >,
  }

  #[ allow( clippy::missing_fields_in_debug ) ]
  impl core::fmt::Debug for ProgramInfo
  {
    fn fmt( &self, f: &mut std::fmt::Formatter< '_ > ) -> std::fmt::Result
    {
      f.debug_struct( "ProgramInfo" )
      .field( "locations", &self.locations.keys().collect::< Vec< _ > >() )
      .field( "ubo_indices", &self.ubo_indices )
      .finish()
    }
  }

  impl ProgramInfo
  {
    /// Binds the WebGL program for use.
    ///
    /// * `gl`: The `WebGl2RenderingContext`.
    pub fn bind( &self, gl : &gl::WebGl2RenderingContext )
    {
      gl.use_program( Some( &self.program ) );
    }
  }

  impl Clone for ProgramInfo
  {
    fn clone( &self ) -> Self
    {
      Self
      {
        program : self.program.clone(),
        locations : self.locations.clone(),
        ubo_indices : self.ubo_indices.clone()
      }
    }
  }

  // An empty shader program.
  //
  // This is typically used as a placeholder or for a simple pass-through rendering pipeline.
  impl_locations!
  (
    EmptyShader,
  );

  // A public struct for a composite shader.
  impl_locations!
  (
    CompositeShader,
    "transparentA",
    "transparentB"
  );

  // Shader used for drawing background from equirectangular map
  impl_locations!
  (
    SkyboxShader,
    "equirectMap",
    "invProjection",
    "invView"
  );
}

crate::mod_interface!
{
  own use
  {
    EmptyShader,
    CompositeShader,
    SkyboxShader
  };

  orphan use
  {
    ShaderProgram,
    ProgramInfo,
    impl_locations
  };
}
