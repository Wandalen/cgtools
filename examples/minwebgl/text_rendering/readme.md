# Text rendering

This example demonstrates how to generate and render 3D text geometry using font data in UFO and TTF formats, leveraging the `web_sys`, `minwebgl`, and `renderer` crates.

## How it is useful

The example showcases several useful techniques and concepts:

* How to create 3D text geometry from font data in both **UFO** and **TTF** formats.

* How to use the **`earcutr`** crate for 2D polygon triangulation, which is essential for creating the front and back faces of the text mesh.

* How to use the **`csgrs`** crate for processing TTF font data and performing constructive solid geometry operations.

* How to construct a `GLTF` object and a `Scene` entirely from in-memory primitives, without loading a file.

* How to set up and use a **`renderer::Renderer`** to render a scene.

* How to implement a post-processing pipeline with **`renderer::SwapFramebuffer`** to apply effects like tonemapping and sRGB conversion.

* How to set up a camera with interactive controls using a separate module.

## How it works

1. **Setup the WebGL context and load fonts**.

   The application initializes a WebGL2 rendering context and an HTML canvas. It then asynchronously loads the font data for several specified fonts. For **UFO** fonts, it loads `.glif` files and parses their XML structure. For **TTF** fonts, it loads the `.ttf` binary data directly.

2. **Generate and arrange text geometry**.

   For each font, the code generates a "CGTools" text mesh. The process is different depending on the font type:

   * **UFO:** The `ufo::text_to_mesh` function parses the font contours, which can contain Bézier curves. It flattens these curves into simple polylines. It then uses **`earcutr`** to triangulate the 2D contours to create the front and back faces of the text mesh. Side faces are generated by extruding the outer and inner contour edges.

   * **TTF:** The `ttf::text_to_mesh` function uses the **`csgrs`** library. This library handles the complex process of parsing the TTF data and generating a 3D mesh by extruding the 2D glyph outlines.

   After generating the geometry, the code constructs `Primitive` and `Mesh` objects, calculates normals for all faces, and positions each text mesh to form two columns in the scene.

3. **Construct the GLTF and Scene**.

   The `primitives_data_to_gltf` function takes the generated primitives and builds a `GLTF` object from scratch. It creates the necessary WebGL buffers for the GPU, populates them with the geometry data (positions, normals, and indices), and adds the meshes to a `Scene` object, which is then ready for rendering.

4. **Setup renderer and post-processing passes**.

   A **`Renderer`** is created to handle the primary rendering of the scene. The code also sets up a **`SwapFramebuffer`** along with a **`ToneMappingPass`** and a **`ToSrgbPass`** to perform post-processing on the final rendered image.

5. **Run the render loop**.

   The main loop continuously renders the scene. Inside the loop, the `Renderer` draws the scene to its main texture. This texture is then passed through the post-processing pipeline using the `SwapFramebuffer` to apply tonemapping and convert the colors to the sRGB space before displaying the final result on the canvas.

## Running

Make sure you have installed all the necessary dependencies. This example requires `trunk` for building and serving the WebAssembly application.

In order to run the example:

1. Navigate to the example's directory in your terminal.

2. Run the command:

```

  trunk serve

```

3. Open your web browser to the address provided by trunk (usually `http://127.0.0.1:8080`).

The application will load the font data, generate the 3D text, set up the WebGL resources, and start the rendering loop, displaying the text with a post-processing effect.

If you want you can:

1. Change the text string to generate different text meshes.

2. Experiment with different fonts by modifying the `font_names` array.

3. Modify the post-processing passes to explore other visual effects.