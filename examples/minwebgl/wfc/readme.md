## Wave function collapse

This example shows how create tile map with wave function collapse algorithm and display it with tile renderer using `WebGl2`. Goal of this example is generate tile map using wave function collapse algorithm and compare existing wfc libraries.

<p align="center">
  <img src="./resources/showcase.png" width="600px">
</p>

### How it is useful

The example shows:
- how import patterns for WFC algorithm from tmx format.
- how use external library WFC algorithm implementation for generating tile maps.
- how convert raw tile map data to texture. 

Rendering details description can be found in [ mapgen_tiles_rendering ]( ../mapgen_tiles_rendering/README.md ) example

### Libraries comparison

See here: [ link ]( ./wfc_libs_comparison.md )

### How it works

Example include such noteworthy steps (for most success crate wfc-image):
 - load tile set texture
 - load from input tile map (TMX) file that generated by Tiled
 - extract pattern from first layer as raw data (`Vec<u8>`)
 - convert pattern raw data to `DynamicImage`
 - use generate_image function for creating tile map `DynamicImage`
 - extract raw data (`Vec<u8>`) from tile map
 - bind tile set to fragment shader as texture array
 - convert and bind tile map to fragment shader as `R8UI` texture
 - render tile map

This steps similar for other libraries.

`wfc` library apply this excecution steps:

1. Learn Patterns: The library analyzes the input sample image (or tileset) to identify all unique local patterns (typically small square blocks like 3x3 or 4x4 pixels). It might also generate rotations and reflections of these patterns based on configuration. These unique patterns form the set of "possible states" or "tiles".

2. Build Adjacency Rules: For each unique pattern, the library determines which other patterns can legally appear next to it in each of the four cardinal directions (up, down, left, right) by examining how they appear together in the original input. This creates a set of compatibility rules.

3. Initialize Output Grid: A grid representing the desired output image size is created. Initially, each cell in this grid is in an "uncollapsed" state, meaning it has a "superposition" of all possible patterns from the learned set; each cell has maximum "entropy".

4. Observation (Collapse): The algorithm enters an iterative loop. In each iteration, it selects a cell in the grid that has the lowest entropy (i.e., the fewest remaining possible patterns, but more than one). From this cell's remaining possibilities, it randomly chooses one pattern (often weighted by frequency from the input) and assigns it to that cell. This cell is now "collapsed", and its entropy becomes zero.

5. Propagation: When a cell is collapsed, its neighbors' possibilities might become invalid according to the adjacency rules. The algorithm propagates this change: it examines the neighbors, removes any pattern from their possibility sets that is incompatible with the newly assigned pattern in the collapsed cell. If a neighbor's set of possibilities changes, this change is then propagated to its neighbors, and so on, potentially triggering a chain reaction across the grid.

6. Check for Contradiction: During propagation, if a cell's set of possible patterns becomes empty, a contradiction has occurred â€“ the choices made have led to an impossible state. The algorithm typically reports failure, and you might need to restart the process.

7. Repeat or Terminate: If no contradiction occurred, the algorithm returns to the Observation step and selects the next lowest-entropy cell to collapse. This loop continues until either a contradiction is found (failure) or all cells in the grid have been collapsed to a single pattern (success).

8. Generate Output: If the algorithm successfully collapses all cells, the final output image is constructed by taking the single pattern assigned to each grid cell and placing its corresponding pixels into the output image buffer.

### Running

Make sure you have installed all the necessary [ dependencies ]( ../../../module/min/minwebgl/readme.md )
In order to run the example navigate to example's directory and run next command:

``` bash
trunk serve
```

If you want to load own tile set image, upload it into `resources` folder as `tileset.png`. 

Tileset image must store tile textures from up to down order, all textures must have equal size without align.

You can change tile map size with SIZE const:

``` rust
const SIZE : usize = 32;
```

You can change pattern size with PATTERN_SIZE const:

``` rust
const PATTERN_SIZE : u32 = 3;
```

PATTERN_SIZE and TMX pattern don't have same size. WFC algorithm will split TMX pattern on smaller pieces with side size `PATTERN_SIZE`.

You need create TMX file with Tiled. This file will be used for loading WFC reference pattern. File can be loaded by pressing button "Choose file". 

Generation will happen when TMX file is changed or when "Generate" button is pressed.

### Optimal settings

For better performance use smaller `SIZE`, `PATTERN_SIZE` and TMX pattern.