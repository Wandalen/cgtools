# Renderer with outlines demo

This example demonstrates how to use a renderer and swapframebuffer to combine a rendered image with post-processed outlines generated by different methods, allowing for a comparison of their visual results and potential performance.

The outlines are achieved using various post-processing techniques that analyze the rendered object's silhouette and other G-buffer information like normals. Used outlines methods: narrow outline, normal depth outline, wide outline.

![Showcase]( ./showcase.png )

## How it is useful

This example showcases several useful techniques and concepts for WebGL2 development:

  * Multi-pass rendering pipeline: Learn how to chain multiple post-processing effects to achieve a complex visual effect.

  * SwapFramebuffer usage: Understand how to use rendered output textures of post-processing effects with SwapFramebuffer for creating multi-pass rendering pipeline.

  * Post-processing effects: Implement a visual effect applied to an entire rendered scene, including different outline algorithms.
  * Renderer usage: How render initial source texture.

  * 3D model loading: See how to load and process 3D models in GLTF format using the gltf crate.

  * G-Buffer: Understand how to render multiple scene properties (position, normal, albedo, object color) into separate textures in a single pass for deferred shading or post-processing.

  * Select render target: How implement switch between different rendered textures for output to screen in real-time.

## How it works

Screen output is created through a multi-pass rendering process:

1. Renderer Pass.

* The 3D object(s) are rendered to an offscreen framebuffer with realistic lighting.

* This texture is used as input for next post-procesing effects.

2. Gbuffer Pass.

  * The 3D object(s) are rendered to an offscreen framebuffer (gbuffer).

  This pass outputs various scene properties into different textures attached to the G-buffer, such as:

  * Position: World-space position and depth information of each fragment.

  * Normal: World-space normal of each fragment.

  * Object Color: A unique color assigned to each distinct object, useful for identifying silhouettes.

  * Albedo/PBR Info: Material properties.

3. Outline Pass.

A common vertex shader (referred to as VS_TRIANGLE in the Rust code, similar to a fullscreen.vert) is used.

One of several fragment shaders is applied, utilizing the textures generated in the G-Buffer Pass to create different outline effects:

  * Narrow Outline (narrow_outline.frag): Uses a Sobel-like operator on the object color and position textures to detect edges and create a tight outline.

  * Normal-Depth Outline (normal_depth_outline.frag): Combines normal and depth information from the G-buffer with the object color to generate a more robust and accurate outline, often better at handling internal edges.

  * Wide Outline (JFA) (wide_outline/jfa_init.frag, wide_outline/jfa_step.frag, wide_outline/outline.frag): This technique uses the Jump Flooding Algorithm to generate a distance field from the object's silhouette.

4. Tonemapping and ToSrgb Passes.

Are used for color correction as final passes. ToSrgb outputs its result texture into screen.

5. SwapFramebuffers object. 

Used for connecting intermeadiant results of every post-processing effect. Output of current pass moving to output texture of SwapFramebuffers. Then SwapFramebuffers applies swap between its input and output and then this textures is used as input and output of next post-processing effect render call. Every pass structure implements trait Pass that require `render` method implementation. Its make pass structures usage unified.

## Running
Ensure you have all the necessary dependencies installed. This example uses trunk for building and serving the WebAssembly application.

To run the example:

Navigate to the example's directory in your terminal.

Run the command:

```bash
  trunk serve
``` 

Open your web browser to the address provided by trunk (usually http://127.0.0.1:8080).

The application will load the GLTF model, compile shaders, set up WebGL resources, and start the rendering loop, displaying the 3D object with outline. You can select different outline types and adjust the thickness using the provided UI controls.

Feel free to replace `old_rusty_car.glb` with your own 3D model, or experiment with the outline parameters (thickness, colors) by modifying the values in the main.rs file.